package dataStructure.sort;

/**
 * @author booty
 * @date 2021/6/28 11:05
 */
public class InsertSort {

    /**
     * 插入排序
     * <p>
     * 默认第一个数为有序，从第二个数开始，使用临时变量保存当前值
     * 若保存的值小于上一个数，将当前的位置，设置为上一个数的值，
     * 依次类推直到最前或保存的值大于上一个数，则将保存的值数插入到当前位置
     * （因当前位置的下一个位置的值已经在上一轮设为了当前值，所以不用担心值被覆盖）
     * <p>
     * 效率不稳定
     * 当排序数组已经非常接近从小到大的顺序时效率极高，高于比较，
     * 当插入排序中后方的数值较小时，其前方的所有元素都会重新赋值，基本等于冒泡，效率极低
     */
    public static int[] insertSort(int[] arr) {
        int temp;
        for (int i = 1; i < arr.length; i++) {
            //仅当前数小于前一个数时进行操作
            if (arr[i] < arr[i - 1]) {
                //保存当前值，防止被之后覆盖
                temp = arr[i];
                //获取当前值的前一个值的下标
                int j = i - 1;
                //循环遍历前面的值，若前值大于当前值，将前值设置为其后面数的值
                while (j >= 0 && temp < arr[j]) {
                    arr[j + 1] = arr[j];
                    j--;
                }
                //前值不大于保存的值或不需要改变顺序，直接将当前位置设为保存的值即可（因循环内-1了，此处需要+1）
                arr[++j] = temp;
            }
        }
        return arr;
    }
}
